# grug for C

This repository provides a C implementation of grug, including the frontend, interpreter backend, and bindings.

The library is packaged as a single grug.c + grug.h pair, and the recommended way to install grug into your project is to copy those source files into your own project. For now they are written as-is, but shortly into the future that file will be generated by a program as an amalgamated build. After that point, grug should also function in the non-amalgam form.

## Example
See the `examples/` directory for usage examples, `test/` for how testing is done. However, here is a super minimal example.

main.c
```C
#include "grug.h"

// Game fns get direct access to the grug state / context from which they are called
// For example, in a system with co-routines, each fiber may have its own grug state.
void game_fn_print_string(grug_state* gst, GRUG_ID me_caller, union grug_value *args) {
    printf("Entity %d said %s\n", me_caller, GRUG_GET_STRING(gst, args, 0));
}

int main(void) {
    // Default settings (libc malloc/free, mods dir in the cwd, etc)
    struct grug_init_settings settings = {0};

    // gst "grug state" contains all of the grug library state
    struct grug_state gst = grug_init(settings);

    // let grug know where to call the print_string game function
    grug_register_game_fn_void(&gst, "print_string", game_fn_print_string);

    // Grab the "ID" of the Dog::on_spawn and Dog::on_bark functions
    // This is not a normal grug object id, but a special function id
    GRUG_ON_FN_ID on_spawn_fn_id = grug_get_fn_id(&gst, "Dog", "on_spawn");
    GRUG_ON_FN_ID on_bark_fn_id = grug_get_fn_id(&gst, "Dog", "on_bark");

    // Get access to the script in question.
    // your file object is simple a handle to the script, and isn't the script itself 
    GRUG_FILE_ID labrador_script = grug_get_script(&gst, "animals/labrador-Dog.grug");

    // The initialization of globals might call game fns, so beware that creating an entity may call game fns
    GRUG_ID dog1 = grug_create_entity(&gst, &labrador_script, dog1_me);
    GRUG_CALL_ARGLESS_VOID(&gst, dog1_me, on_spawn_fn_id);
    
    GRUG_ID dog2 = grug_create_entity(&gst, &labrador_script, dog2_me);
    GRUG_CALL_ARGLESS_VOID(&gst, dog2_me, on_spawn_fn_id);
    
    while(true) {
        // This reloads any script and resource changes, recompiling files if nessesary
        // Since you got IDs instead of the actual structures, grug can update things behind the scenes
        // grug_update will also cause entities to re-init their globals, calling game fns if needed
        grug_update(&gst);
        // Although you can ask grug about everything that updated if needed, in apis similar to this
        if(grug_script_was_updated(&gst, labrador_script)) {
            GRUG_CALL_VOID(&gst, dog1_me, on_bark_fn_id, GRUG_ARGS(GRUG_ARG_STRING("Woof")));
            GRUG_CALL_VOID(&gst, dog2_me, on_bark_fn_id, GRUG_ARGS(GRUG_ARG_STRING("Arf")));
        }
    }

    // Technically unreachable (oops) but this will also clean up all the entities and scripts
    // scripts and entities can be destroyed individually of course
    grug_deinit(&gst);
}
```

animals/labrador-Dog.grug
```py
on_bark(sound: string) {
    print_string(sound)

    # Print "arf" a second time
    if sound == "arf" {
        print_string(sound)
    }
}
```

